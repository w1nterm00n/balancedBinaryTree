<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>binary trees...</title>
</head>
<body>
    
</body>
<script>


    class Node {
        constructor(data){
            this.data = data,   //число записанное в нем
            this.right = null, // ссылка на Node справа
            this.left = null   // ссылка на Node слева
        }
        setRight (value) {
            this.right = value;
        }
        setLeft (value) {
            this.left = value;
        }

        
    }

    let treeManipulation = {

        sortArr (arr) {
            //убираю дублирующиеся числа и расставляю по порядку
            arr.sort(function (a, b) {
                return a - b;
            });
            let uniqueArr = [];
            arr.forEach((element) => {
                if (!uniqueArr.includes(element)) {
                    uniqueArr.push(element);
                }
            });
            arr = uniqueArr;
            return arr;
        },

        buildSortedTree (arr) {
            if (arr.length === 0){
                return null;
            }
            let rootIndex = Math.ceil(arr.length/2) - 1;

            let rightSide = [];
            let leftSide = [];
            for (let i = 0; i < rootIndex; i++){
                leftSide.push(arr[i])
            };

            for (let i = rootIndex+1; i < arr.length; i++){
                rightSide.push(arr[i])
            };

            var node = new Node(arr[rootIndex]);
            node.setRight(this.buildSortedTree(rightSide));
            node.setLeft(this.buildSortedTree(leftSide));

            return node;
        },

        makeTree (arr) {
            let sortedArr = this.sortArr(arr);
            return this.buildSortedTree(sortedArr);
        },

        prettyPrint (node, prefix = "", isLeft = true) {
            if (node === null) {
                return;
            }
            if (node.right !== null) {
                this.prettyPrint(node.right, `${prefix}${isLeft ? "│   " : "    "}`, false);
            }
            console.log(`${prefix}${isLeft ? "└── " : "┌── "}${node.data}`);
            if (node.left !== null) {
                this.prettyPrint(node.left, `${prefix}${isLeft ? "    " : "│   "}`, true);
            }
        },


        insert (value, root) {
            if (value == root.data) {
                return
            } else if (value > root.data) {
                //right side
                if (root.right === null) {
                    root.right = new Node(value);
                } else {
                    this.insert(value, root.right);
                }
            } else {
                //left side
                if (root.left === null) {
                    root.left = new Node(value);
                } else {
                    this.insert(value, root.left);
                }
            }
        },

        findLeftChild (root) {
            //поиск самого нижнего левого узла
            if (root.left == null) {
                return root
            } else {
                return this.findLeftChild(root.left);
            }
        },

        delete (value, root) {
            if (value == root.data) {
                if ((root.right == null) && (root.left == null)) {
                    //1. если у него нет детей
                    root.data = null;
                    return;
                }
                if ((root.right == null) || (root.left == null)) {
                    //2. если один ребенок
                    let child = {};
                    if (root.right !== null){
                        child = root.right;
                        root.data = child.data;
                        root.right = null;
                    } else {
                        child = root.left;
                        root.data = child.data;
                        root.left = null;
                    }
                    
                }
                if ((root.right !== null) && (root.left !== null)) {
                    //3. если двое детей
                        //идём в правую ветку
                        //a дальше опускаемся как можно глубже в лево
                        //пока не находим самого нижнего левого ребенка (y него root.left = null)
                        //value этого ребенка сохраняем в переменную child
                        //присваиваем самому ребенку value = null
                        //a узлу который надо удалить присваиваем value из child
                    if (root.right.left == null) {
                        root.data = root.right.data;
                        root.right = root.right.right;
                    } else {
                        let child = this.findLeftChild(root.right);
                        root.data = child.data;
                        child.data = null;
                    }
                }
                return;
            } else if (value > root.data) {
                //right side
                if (root.right == null) {
                    return "no such value"
                } else {
                    this.delete(value, root.right)
                }
            } else {
                //left side
                if (root.left == null) {
                    return "no such value"
                } else {
                    this.delete(value, root.left)
                }
            }
        }
    }




    let tree = treeManipulation.makeTree([ 60, 2, 5, 44, 102, 34, 155, 3, 43, 7, 100, 6]);
    treeManipulation.delete(6, tree);
    treeManipulation.prettyPrint(tree);


    //2. Write a find function that accepts a value and returns the node with the given value.
</script>
</html>